{
  "contractName": "A",
  "abi": [],
  "bytecode": "0x6080604052348015600f57600080fd5b50603580601d6000396000f3006080604052600080fd00a165627a7a723058207399c5a08fed3c09a9001b22c319f4f96896b61cf4ae50e8b7fbfbfb88e168b10029",
  "deployedBytecode": "0x6080604052600080fd00a165627a7a723058207399c5a08fed3c09a9001b22c319f4f96896b61cf4ae50e8b7fbfbfb88e168b10029",
  "sourceMap": "25:15:9:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;25:15:9;;;;;;;",
  "deployedSourceMap": "25:15:9:-;;;;;",
  "source": "pragma solidity ^0.4.24;\ncontract A {\n\n}\n//\n//import '../openzeppelin-solidity/contracts/math/SafeMath.sol';\n//\n//import './TwoKeyEconomy.sol';\n//import './TwoKeyTypes.sol';\n//import './TwoKeyEventSource.sol';\n//import './TwoKeyCampaignARC.sol';\n//import \"./TwoKeyCampaignInventory.sol\";\n//import \"./TwoKeyWhitelisted.sol\";\n//\n///// TODO: method to set contractor public key  (when user create campaign we generate a link)\n///// TODO: Somehow to check if contractor public key is set\n///// TODO: Add inventory (ETHCrowdsale()?)\n///// TODO: Method to buy inventory\n//\n///// TODO: TwoKeyAcquisitionCampaign should be called\n///// TODO: TwoKeyAcquisitionCampaignERC20\n///// We can purchase with either 2key - ether - 721\n///// TODO: TwoKeyAcquisitionCampaignERC721\n///// TODO: Crowdsale can be removed (?)\n//contract TwoKeyCampaign is TwoKeyCampaignARC, TwoKeyTypes {\n//\n//\tusing SafeMath for uint256;\n//\n//\tstruct Conversion {\n//\t\taddress from;\n//\t\tuint256 payout;\n//\t\taddress converter;\n//\t\tbool isFulfilled;\n//\t\tbool isCancelled;\n//\t\tuint256 tokenID; //can be removed\n//\t\taddress assetContract;\n//\t\tuint256 indexOrAmount; //rename baseAmount , bonusAmount (total amount can be calculated)\n//\t\tCampaignType campaignType;\n//\t\tuint256 openingTime;\n//\t\tuint256 closingTime;\n//\t}\n//\n//\tmapping (address => Conversion) public conversions;\n//\n//    uint balance;\n//\n//\n//\t// emit through it events for backend to listen to\n//\tTwoKeyEventSource eventSource;\n//\n//\t// 2key token\n//\tTwoKeyEconomy economy;\n//\n//\t// whitelists will be managed by their ownership\n//\t// they are the vehicles to convey KYC for different roles: converter, influencer, contractor\n//\t// whitelists are outside the campaign\n//\t// these whtelists may be shared across campaigns\n//\n//\t// whitelist of influencers, to which users are added after kyc\n//\t// TODO (udi) what should I do if I dont want to manage a white list?\n//\tTwoKeyWhitelisted whitelistInfluencer;\n//\n//\t// whitelist of converters, to which users are added after kyc\n//\tTwoKeyWhitelisted whitelistConverter;\n//\n//\n//\t// Composable asset factory\n//\tTwoKeyCampaignInventory twoKeyCampaignInventory;\n//\n//\n//\t// prices of assets\n//\t// TODO (udi) there should be just one token->address->price you don't need two maps\n//\t// TODO: We don't need mapping bcs selling 1 type only can be only price\n//\tmapping(uint256 => mapping(address => uint256)) prices;\n//\n//\t// rate of conversion from TwoKey to ETH\n//\tuint256 rate;\n//\n//\n//\tuint openingTime;\n//\tuint closingTime;\n//\n//\taddress contractor;\n//\taddress moderator;\n//\n//\t// parameters of escrow\n//\n//\t// how long will hold asset in escrow\n//\tuint256 expiryConversion;\n//\n//\t// percentage of payout to. be paid for moderator for escrow\n//\tuint256 escrowPercentage;\n//\n//    // maximum precentage of all rewards out of payout for asset\n//    // acording to incentive model, for each campaign,\n//    // we set its maximum reward which the campaign is created as a precentage of the payout for\n//    // an item sold in the campaign\n//    // this reward is spread among influencers causing in some way a conversion\n//    // the incentive model determines how to spread the reward\n//\tuint256 maxPi;\n//\n//\n//    // is the influencer eligible for participation in campaign\n//\tmodifier isWhiteListedInfluencer() {\n//\t\trequire(whitelistInfluencer.isWhitelisted(msg.sender));\n//\t\t_;\n//\t}\n//\n//\t// is the converter eligible for participation in conversion\n//    modifier isWhitelistedConverter() {\n//        require(whitelistConverter.isWhitelisted(msg.sender));\n//        _;\n//    }\n//\n//    modifier didConverterConvert() {\n//        Conversion memory c = conversions[msg.sender];\n//    \trequire(c.tokenID != 0);\n//    \trequire(!c.isFulfilled && !c.isCancelled);\n//        _;\n//    }\n//\n//\t  modifier isOngoing() {\n//\t    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n//\t    _;\n//\t  }\n//\n//\t  modifier isClosed() {\n//\t    require(now > closingTime);\n//\t    _;\n//\t  }\n//\n//\t// if we just work with two key tokens,\n//\t// rate is 1, and all prices are in two key tokens\n//\t/*\n//\n//\t */\n//\t/// TODO: Check the best way to emit event for creation\n//\tconstructor(\n//\t\tTwoKeyEventSource _eventSource,\n//\t\tTwoKeyEconomy _economy,\n//\t\tTwoKeyWhitelisted _whitelistInfluencer,\n//\t\tTwoKeyWhitelisted _whitelistConverter,\n//\t\tTwoKeyCampaignInventory _twoKeyCampaignInventory,\n//\n//\t\taddress _contractor,\n//\n//\t\t// set moderator as admin of twokeywhitelist contracts here\n//\t\taddress _moderator,\n//\n//\t\tuint256 _openingTime,\n//\t\tuint256 _closingTime,\n//\t\tuint256 _expiryConversion,\n//\t\tuint256 _escrowPercentage,\n//\t\tuint256 _rate,\n//\t\tuint256 _maxPi) TwoKeyCampaignARC(_eventSource, _contractor) StandardToken() public {\n//\n//\n//\t\t/// requires that all contracts from constructor are already deployed\n//\t\trequire(_eventSource != address(0));\n//\t\trequire(_economy != address(0));\n//\n//\t\t/// uint values\n//\t\trequire(_rate > 0);\n//\t\trequire(_maxPi > 0);\n//\n//\t\teconomy = _economy;\n//\n//\t\tcontractor = _contractor;\n//\t\tmoderator = _moderator;\n//\n//\t\topeningTime = _openingTime;\n//\t\tclosingTime = _closingTime;\n//\n//\n//\t\texpiryConversion = _expiryConversion;\n//\t\tescrowPercentage = _escrowPercentage;\n//\n//\n//\t\twhitelistInfluencer = _whitelistInfluencer;\n//\t\twhitelistConverter = _whitelistConverter;\n//\t\ttwoKeyCampaignInventory = _twoKeyCampaignInventory;\n//\n//\t\trate = _rate;\n//\n////\t\t in general max_pi is dynamic and is computed by the incentive model\n////\t     per conversion\n////\t     there should be a discount - but not for now\n//\n//        maxPi = _maxPi;\n////\t\teventSource.created(address(this), contractor);\n//\n//\t}\n//\n//\t/// add modifiers who can call this\n////    function addAdminRolesAndBalancesAfterDeployed() public {\n////\t\ttwoKeyCampaignInventory.adminAddRole(msg.sender, twoKeyCampaignInventory.getControllerRole());\n////\t\ttwoKeyCampaignInventory.adminAddRole(contractor, twoKeyCampaignInventory.getControllerRole());\n////\t\ttwoKeyCampaignInventory.adminAddRole(moderator, twoKeyCampaignInventory.getControllerRole());\n////\t\tbalances[msg.sender] = totalSupply_;\n////    }\n//\n//    /*\n//\t    fulfills a fungible asset purchase\n//\t    creates the escrow for a fungible asset\n//\t    computes the payout\n//\t    transfers to the escrow the asset purchased\n//    */\n//\tfunction fulfillFungibleTwoKeyToken(\n//\t\taddress _from,\n//\t\tuint256 _tokenID,\n//\t\taddress _assetContract,\n//\t\tuint256 _amount)  internal {\n//\t\trequire(_amount > 0 && prices[_tokenID][_assetContract] > 0);\n//\t\tuint256 payout = prices[_tokenID][_assetContract].mul(_amount).mul(rate);\n//\t\trequire(economy.transferFrom(msg.sender, this, payout));\n//\t\tConversion memory c = Conversion(_from, payout, msg.sender, false, false, _tokenID, _assetContract, _amount, CampaignType.CPA_FUNGIBLE, now, now + expiryConversion * 1 minutes);\n//\t\t// move funds\n//\t\ttwoKeyCampaignInventory.removeFungibleAssets(_tokenID, _assetContract, _amount);\n//\t\teventSource.escrow(address(this), msg.sender, _tokenID, _assetContract, _amount, CampaignType.CPA_FUNGIBLE);\n//\t\tconversions[msg.sender] = c;\n//\t}\n//\n//\n//    /*\n//\t    fulfills a non fungible asset purchase\n//\t    creates the escrow for a fungible asset\n//\t    computes the payout\n//\t    transfers to the escrow the asset purchased\n//\n//    */\n//\n//\tfunction fulfillNonFungibleTwoKeyToken(address _from, uint256 _tokenID, address _assetContract, uint256 _index) isOngoing internal {\n//\t\taddress assetToken = address(\n//\t      keccak256(abi.encodePacked(_assetContract, _index))\n//\t    );\n//\t\trequire(_index != 0 && prices[_tokenID][assetToken] > 0);\n//\t\tuint256 payout = prices[_tokenID][assetToken].mul(rate);\n//\t\trequire(economy.transferFrom(msg.sender, this, payout));\n//\t\tConversion memory c = Conversion(_from, payout, msg.sender, false, false, _tokenID, _assetContract, _index, CampaignType.NonFungible, now, now + expiryConversion * 1 minutes);\n//\t\t// move funds\n//\t\ttwoKeyCampaignInventory.setFungibleAssetsToZero(_tokenID, _assetContract);\n//\t\teventSource.escrow(address(this), msg.sender, _tokenID, _assetContract, _index, CampaignType.NonFungible);\n//\t\tconversions[msg.sender] = c;\n//\t}\n//\n//\t/**\n//     * given the total payout, calculates the moderator fee\n//     * @param  _payout total payout for escrow\n//     * @return moderator fee\n//     */\n//    function calculateModeratorFee(uint256 _payout) internal view returns (uint256)  {\n//        if (escrowPercentage > 0) { // send the fee to moderator\n//            uint256 fee = _payout.mul(escrowPercentage).div(100);\n//            return fee;\n//        }\n//        return 0;\n//    }\n//\n//    /**\n//     * transferAssetTwoKeyToken\n//     * @param  _tokenID  sku of asset\n//     * @param  _assetContract erc721 representing the asset class\n//     * @param  _assetTokenIDOrAmount  unique index of asset or amount of asset\n//     * @param  _type Fungible or NonFungible\n//     *\n//     * transfer the asset to the converter,\n//     */\n//    function transferAssetTwoKeyToken(\n//        uint256 _tokenID,\n//        address _assetContract,\n//        uint256 _assetTokenIDOrAmount,\n//        CampaignType _type) isWhitelistedConverter didConverterConvert public {\n//        actuallyFulfilledTwoKeyToken();\n//        if (_type == CampaignType.NonFungible) {\n//\t\t\trequire(twoKeyCampaignInventory.transferNonFungibleAsset(msg.sender, _tokenID, _assetContract, _assetTokenIDOrAmount));\n//        } else if (_type == CampaignType.CPA_FUNGIBLE) {\n//\t\t\trequire(twoKeyCampaignInventory.transferFungibleAsset(msg.sender, _tokenID, _assetContract, _assetTokenIDOrAmount));\n//        }\n//\n//    }\n//    /// TODO: Contractor names moderator, and moderator manages whitelist\n//    /// TODO: Otherwise: Contractor can name moderator, and as part of issuing of twokeycampaign, we issue whitelist contract where we\n//    /// TODO: name the moderator (Should be some kind of admin)\n//    function cancelledEscrow(\n//    \taddress _converter,\n//        uint256 _tokenID,\n//        address _assetContract,\n//        uint256 _assetTokenIDOrAmount,\n//        CampaignType _type) internal {\n//        Conversion memory c = conversions[_converter];\n//        c.isCancelled = true;\n//        conversions[_converter] = c;\n//        if (_type == CampaignType.NonFungible) {\n//\t        address assetToken = address(\n//\t\t      keccak256(abi.encodePacked(_assetContract, _assetTokenIDOrAmount))\n//\t\t    );\n//\t\t\ttwoKeyCampaignInventory.setFungibleAssetsToOne(_tokenID, _assetContract);\n//        } else if (_type == CampaignType.CPA_FUNGIBLE) {\n//\t\t\ttwoKeyCampaignInventory.addFungibleAssets(_tokenID, _assetContract, _assetTokenIDOrAmount);\n//        }\n//\n//        require(economy.transfer(_converter, (c.payout).mul(rate)));\n//    }\n//\n//\n//    /**\n//     * cancelAssetTwoKey\n//     * cancels the purchase buy transfering the assets back to the campaign\n//     * and refunding the converter\n//     * @param  _tokenID  sku of asset\n//     * @param  _assetContract erc721 representing the asset class\n//     * @param  _assetTokenIDOrAmount unique index of asset or amount of asset\n//     * @param  _type NonFungible or Fungible\n//     *\n//     */\n//\t// comment onlyRole(ROLE_CONTROLLER)\n//    function cancelAssetTwoKey(\n//        address _converter,\n//        uint256 _tokenID,\n//        address _assetContract,\n//        uint256 _assetTokenIDOrAmount,\n//        CampaignType _type)  public returns (bool) {\n//    \tConversion memory c = conversions[_converter];\n//\t    require(c.tokenID != 0 && !c.isCancelled && !c.isFulfilled);\n//\t    if (_type == CampaignType.NonFungible) {\n//\t    \tcancelledEscrow(_converter, _tokenID, _assetContract, _assetTokenIDOrAmount, CampaignType.NonFungible);\n//\t        eventSource.cancelled(address(this), _converter, _tokenID, _assetContract, _assetTokenIDOrAmount, CampaignType.NonFungible);\n//\t    } else if (_type == CampaignType.CPA_FUNGIBLE) {\n//\t    \tcancelledEscrow(_converter, _tokenID, _assetContract, _assetTokenIDOrAmount, CampaignType.CPA_FUNGIBLE);\n//        \teventSource.cancelled(address(this), _converter, _tokenID, _assetContract, _assetTokenIDOrAmount, CampaignType.CPA_FUNGIBLE);\n//\t    }\n//        return true;\n//    }\n//\n//\t//onlyRole(ROLE_CONTROLLER) - comment\n//    function expireEscrow(\n//\t\taddress _converter,\n//\t\tuint256 _tokenID,\n//\t\taddress _assetContract,\n//\t\tuint256 _assetTokenIDOrAmount,\n//\t\tCampaignType _type)  public returns (bool){\n//\t    Conversion memory c = conversions[_converter];\n//\t    require(c.tokenID != 0 && !c.isCancelled && !c.isFulfilled);\n//    \trequire(now > c.closingTime);\n//\t\tcancelledEscrow(_converter, _tokenID, _assetContract, _assetTokenIDOrAmount, _type);\n////\t\temit Expired(address(this));\n//\t\treturn true;\n//\t}\n//\n//\n//    /**\n//     * calculates moderetor fee, pays the moderator,\n//     * computes total reward\n//     * transfer payout to contractor, deducting the fee and the total reward\n//     * asks the campaign to distribute rewards to influencers\n//     */\n//\n//\tfunction actuallyFulfilledTwoKeyToken() internal {\n//\t\tConversion memory c = conversions[msg.sender];\n//        c.isFulfilled = true;\n//        conversions[msg.sender] = c;\n//\t\tuint256 fee = calculateModeratorFee(c.payout);\n//        require(economy.transfer(moderator, fee.mul(rate)));\n//        uint256 payout = c.payout;\n//        uint256 maxReward = maxPi.mul(payout).div(100);\n//\n//        // transfer payout - fee - rewards to seller\n//        require(economy.transfer(contractor, (payout.sub(fee).sub(maxReward)).mul(rate)));\n//\n//        transferRewardsTwoKeyToken(c.from, maxReward.mul(rate));\n//        eventSource.fulfilled(address(this), c.converter, c.tokenID, c.assetContract, c.indexOrAmount, c.campaignType);\n//\t}\n//\n//\t// set price for fungible asset held by the campaign\n//\t// onlyRole(ROLE_CONTROLLER) - removed temp\n//\tfunction setPriceFungible(uint256 _tokenID, address _assetContract, uint256 _pricePerUnit)  public {\n//\t\tprices[_tokenID][_assetContract] = _pricePerUnit;\n//\t}\n//\n//\t// set price for a non fungible asset held by the campaign\n//\t// onlyRole(ROLE_CONTROLLER) - removed temp\n//\tfunction setPriceNonFungible(uint256 _tokenID, address _assetContract, uint256 _index, uint256 _pricePerUnit)  public {\n//\t\taddress assetToken = address(\n//\t      keccak256(abi.encodePacked(_assetContract, _index))\n//\t    );\n//\t\tprices[_tokenID][assetToken] = _pricePerUnit;\n//\t}\n//\n//\t// an influencer that wishes to cash an _amount of 2key from the campaign\n//\tfunction redeemTwoKeyToken(uint256 _amount) public {\n//        require(xbalancesTwoKey[msg.sender] >= _amount && _amount > 0);\n//        xbalancesTwoKey[msg.sender] = xbalancesTwoKey[msg.sender].sub(_amount);\n//        economy.transferFrom(this, msg.sender, _amount);\n//    }\n//\n//    /**\n//  \t * buy product with twokey token,\n//  \t * _from is the influencer from which you received the referral\n//  \t * _tokenID is the asset sku\n//  \t * _assetContract - erc20 (fungible) or erc721 (non fungible) which represents the class of the asset\n//  \t * _amountOrIndex - for erc20 amount in asset class, for erc21 index within asset class\n//  \t */\n//\tfunction buyFromWithTwoKey(\n//\t\taddress _from,\n//\t\tuint256 _tokenID,\n//\t\taddress _assetContract,\n//\t\tuint256 _amountOrIndex,\n//\t\tCampaignType _campaignType) public payable {\n//\t\tif (_campaignType == CampaignType.CPA_FUNGIBLE) {\n//\t\t\tfulfillFungibleTwoKeyToken(_from, _tokenID, _assetContract, _amountOrIndex);\n//\t\t} else if (_campaignType == CampaignType.NonFungible) {\n//\t\t\tfulfillNonFungibleTwoKeyToken(_from, _tokenID, _assetContract, _amountOrIndex);\n//\t\t}\n//\t}\n//\n//\n//\tfunction addFungibleInventory(uint256 _tokenID, address _assetContract, uint256 _amount) public {\n//\t\ttwoKeyCampaignInventory.addFungibleAsset(_tokenID, _assetContract, _amount);\n//\t}\n//\n//\tfunction getInventoryBalance() public view returns (uint256) {\n//\t\treturn economy.balanceOf(address(twoKeyCampaignInventory));\n//\t}\n//}\n//\n",
  "sourcePath": "/Users/aydnep/2key/contracts/contracts/2key/TwoKeyCampaign.sol",
  "ast": {
    "absolutePath": "/Users/aydnep/2key/contracts/contracts/2key/TwoKeyCampaign.sol",
    "exportedSymbols": {
      "A": [
        2362
      ]
    },
    "id": 2363,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 2361,
        "literals": [
          "solidity",
          "^",
          "0.4",
          ".24"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:24:9"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 2362,
        "linearizedBaseContracts": [
          2362
        ],
        "name": "A",
        "nodeType": "ContractDefinition",
        "nodes": [],
        "scope": 2363,
        "src": "25:15:9"
      }
    ],
    "src": "0:15813:9"
  },
  "legacyAST": {
    "absolutePath": "/Users/aydnep/2key/contracts/contracts/2key/TwoKeyCampaign.sol",
    "exportedSymbols": {
      "A": [
        2362
      ]
    },
    "id": 2363,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 2361,
        "literals": [
          "solidity",
          "^",
          "0.4",
          ".24"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:24:9"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 2362,
        "linearizedBaseContracts": [
          2362
        ],
        "name": "A",
        "nodeType": "ContractDefinition",
        "nodes": [],
        "scope": 2363,
        "src": "25:15:9"
      }
    ],
    "src": "0:15813:9"
  },
  "compiler": {
    "name": "solc",
    "version": "0.4.24+commit.e67f0147.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "2.0.1",
  "updatedAt": "2018-09-09T08:41:36.620Z"
}